# Verilog代码风格和编程规范指导

## 目录

* [一般规则](#1-%e4%b8%80%e8%88%ac%e8%a7%84%e5%88%99)
* [文件头](#2-%e6%96%87%e4%bb%b6%e5%a4%b4)
* [宏定义](#3-%e5%ae%8f%e5%ae%9a%e4%b9%89)
* [模块及端口声明](#4-%e6%a8%a1%e5%9d%97%e5%8f%8a%e7%ab%af%e5%8f%a3%e5%a3%b0%e6%98%8e)
* [逻辑代码](#5-%e9%80%bb%e8%be%91%e4%bb%a3%e7%a0%81)
* [设计规范及建议](#6-%e8%ae%be%e8%ae%a1%e8%a7%84%e8%8c%83)

## 1. 一般规则
* 缩进宽度：4（转换为空格）
* 对齐规则：```begin, (, [, {```和对应语句处于同一行
* 二元运算符前后、```if```等关键字后、```begin```前用空格分隔
* 变量命名：在明确含义的情况下尽量简洁
* 声明变量时尽量保持每行一个变量。1bit且具有相同类型和意义的变量可以用一行代码声明
* 注释：语义明确；简洁（避免重复代码）；必要时可以用字符形式画简单框图


## 2. 文件头
以注释的形式对文件的内容进行简要描述，尽量简洁。
```verilog
//=============================================================================
// File Name    : {文件名}
// Created On   : {创建时间 yyyy-mm-dd hh:mm:ss}
// Last Modified: {更新日期 yyyy-mm-dd hh:mm:ss}
// Author       : {作者}
// Description  : {功能描述}
//=============================================================================
```
所有逻辑模块必须定义``` `timescale```。

## 3. 宏定义
宏定义统一采用大写加下划线的形式命名，在宏定义前给出相应的注释说明变量含义。对于有单位的变量（如时间、频率等），建议在变量名结尾加上单位。
```verilog
// 系统统一用时钟上升沿
`define CLK_EDGE posedge clk
// DDR接口位宽：256bit
`define DDR_BW 256
// 时钟频率：100MHz
`define CLK_FREQ_MHZ 100
```

全局统一的宏定义在独立的.vh文件中进行声明，以``` `include```的方式加入到需要的文件中。

## 4. 模块及端口声明
**模块的声明**：一个文件只允许包含一个模块的定义，文件名应和模块名称一致。模块的命名采用小写字母和下划线组合的形式，命名应尽量简洁。端口命名时不要将模块名加入到端口名称中。

**模块的参数**：采用大写加下划线命名，命名风格同宏定义。端口参数只允许以下两类：
1. 端口位宽设置时需要用到的参数。如不可配置(比如推导出的参数)，则在名称前加```C_```前缀表明不可配置。
2. 外部可配置的参数。应在注释中注明可配置的参数范围。

**模块的端口**：

端口类型 | 命名规则 | 说明
:-      | :-       | :-
时钟 | ```clk{_名称}{_频率}``` | 包含多时钟输入的模块通过名称区分不同的时钟<br>对频率有要求的时钟应注明频率。
复位 | ```{a}rst{_n}``` | 用a前缀注明异步，n后缀注明低有效。
独立端口 | ```{i/o/t}{_名称}``` | i/o/t注明input/output/tri。
协议端口 | ```{s/m}{_协议类型}{_名称}``` | s/m代表master/slave，也可以根据需要来定义缩写。

必要时可以在端口信号后加注释。同一协议下的一组信号应相邻放置，并可在该组信号前通过注释注明其功能。向量端口统一采用```[{位宽} -1 : 0]```的方式注明位宽，出于美观建议对齐一组信号的位宽定义中的冒号。

**样例**

```verilog
module adder_tree#(
    parameter DATA_IN_W     = 8,    // 输入数据位宽
    parameter DATA_NUM      = 16,   // 输入数据个数
    parameter C_DATA_O_W    = DATA_IN_W + $clog2(DATA_NUM)
                                    // 输出数据位宽
    )(
    input   clk,
    input   rst_n,          // 同步低电平复位

    input   i_config,       // 配置脉冲，高电平有效
    input   i_round_type,   // 输出舍入类型，0: 截断，1：四舍五入

    // 输入数据，axi_stream slave接口
    input   [DATA_IN_W * DATA_NUM   -1 : 0] s_axis_din_data,
    input                                   s_axis_din_valid,
    output                                  s_axis_din_ready,

    // 输出数据，axi_stream master接口
    output  [C_DATA_O_W             -1 : 0] m_axis_dout_data,
    output                                  m_axis_dout_valid,
    input                                   m_axis_dout_ready,
    );

    /* 模块逻辑代码 */

endmodule
```

## 5. 逻辑代码

### 5.1. 变量声明

变量的命名采用小写字母和下划线组合的形式。对于低电平有效的信号，应采用```_n```后缀，对于寄存器变量（注意不是指reg类型），应采用```_r```后缀。对于单纯为了延时而使用的寄存器变量，也可以采用```_d{x}```表示，x应从0开始计数。当仅有一个延时时可以不写x以表示d0。采用数组移位进行延时操作时，应从0开始依次向高位移位，以确保```_d{x}```和```_d[x]```的意义一致。不包含后缀的变量默认为组合逻辑的输出。

### 5.2. 例化模块

例化模块时模块实例名称采用```u_{模块名}_{序号}```的方式，或者```u_{模块名}_{实际功能}```的方式。应保证所有可以配置的参数被配置，且所有端口被连接。悬空的端口也应该以```/* not_used */```填入端口。模块例化时每个端口及其连接独立占据一行，顺序同模块声明时的顺序一致。

子模块的端口如果和顶层端口直接连接，则无须声明中间变量，直接连接即可。对于子模块之间的信号连接，中间变量的命名应综合考虑两边端口的名称，去除端口模式（i,o,m,s等），添加连接两端的名称，保留端口功能。可以根据实际情况进行命名。

同一个模块需要例化多个的时候，应采用generate块的形式，明确接口信号的连接方式。不要采用模块数组的形式，避免接口信号自动连接出现错误。

### 5.3. 局部参数

模块内部参数采用```localparam```关键字声明，命名采用大写字母和下划线组合的形式。涉及直接赋值的参数应标明位宽。

### 5.4. 代码块

基本规则：相关的逻辑连同变量声明尽量放在一起。可区分的逻辑块可以用注释分隔，注明每一段代码的大致功能。相似行为（具有相同赋值条件）的寄存器可以合并到一个```always```块中实现，不相似的在不同的```always```块中实现。

组合逻辑：一般采用```assign```。需要使用```always```时，为防止敏感表疏漏，统一采用```always @ (*)```

状态机：采用三段格式（状态定义+状态跳转+次态逻辑）

```verilog
localparam S_IDLE   = 2'b00;    // 状态机状态编码
localparam S_BUSY   = 2'b01;
localparam S_DONE   = 2'b10;

reg     [1 : 0] state_r;        // 当前状态
wire    [1 : 0] state_nxt;      // 次态

always @ (posedge clk) begin    // 状态跳转
    if (~rst_n) begin
        state_r <= S_IDLE;
    end
    else begin
        state_r <= state_nxt;
    end
end

always @ (*) begin              // 次态逻辑
    case(state_r)
    S_IDLE: begin
        state_nxt = ...
    end
    S_BUSY: ...
    S_DONE: ...
    default: ...
    endcase
end
```

逻辑表达式：较长的逻辑表达式可以通过换行的方式增加可读性

### 5.5. 属性
为变量/模块增加属性可以为综合和调试提供帮助。但是由于不同的平台通常定义了不同的属性，因此应避免直接使用某一平台所定义的属性。另一方面，属性在调试和综合时可能不同，为了避免大规模手工删改代码中用到的属性，应采用宏定义的方式来维护：
```verilog
`define XILINX
`define DEBUG

`ifdef DEBUG
    `ifdef XILINX
        `define MARK_DEBUG (*mark_debug = "TRUE"*)
    `endif

    `ifdef ALTERA
        `define MARK_DEBUG // 另外的定义
    `endif
`else
    `define MARK_DEBUG
`endif

// 代码部分
`MARK_DEBUG
reg a;
```

## 6. 设计规范和建议

### 6.1. 一致性

* 尽可能地采用统一的复位形式（同/异步，高/低复位）。对于Xilinx的FPGA设计，推荐的方式是采用同步高电平复位。
* 采用统一的握手协议及命名，避免不同模块之间对协议有不同理解。建议采用AXI总线的ready和valid握手方式，即互相不依赖，仅当两者同时为高时有效。

### 6.2. 时序约束的优化

基本原则：好的时序是设计出来的而不是约束出来的，在编码时就应该考虑设计的时序问题。

* **减少逻辑延时**：对长的逻辑表达式或长位宽的数据进行组合逻辑操作应慎重。必要时采用流水线等方式优化设计。对于FPGA而言，由于其底层硬件单元就包含LUT，MUX，进位链等资源，可以适当放宽对相应逻辑的要求。

* **降低布线长度**：对FPGA设计来说，布局布线拥塞导致时序无法收敛的情况很常见。最直接的方法是减小设计规模。也可以通过```set_false_path```和```multi_cycle_path```等约束来放宽对一些路径的时序约束，从而让综合工具优先满足另一些路径的时序。在特定情况下可以对设计进行物理位置约束，人为地优化布局。

* **减小扇出**：过大的扇出通常出现在：复位/长流水线的阻塞（使能）信号/大规模阵列的数据广播。复位信号在确保功能正确地情况下可以人为地用寄存器延时一个周期。对于FPGA而言，也可以采用BUFG来提高信号驱动能力。带有使能信号的长流水线可以在中间进行一次截断。数据广播可以增加树形寄存器结构或者采用脉动阵列的形式减少扇出。采用```(*max_fanout*)```属性也可以让工具自动进行寄存器复制等优化手段。

* **尝试不同的布线策略**：布局布线过程一般是基于一些非确定的搜索和优化方法，很难直接控制。因此可以在布局布线时尝试不同的策略，选择最优的结果。一般而言很难根据经验判断某种布局布线的策略可能更好，最好是去尝试所有策略。

### 6.3. 资源占用的优化

* **适配FPGA资源的逻辑设计**：

* 

### 6.4. 异步信号的处理

